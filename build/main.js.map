{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["/*\n * Created with @iobroker/create-adapter v2.1.1\n */\n\n// The adapter-core module gives you access to the core ioBroker functions\n// you need to create an adapter\nimport * as utils from \"@iobroker/adapter-core\";\n// Load your modules here, e.g.:\nimport axios, { AxiosInstance } from \"axios\";\nimport https from \"https\";\nimport { DOMParser } from \"xmldom\";\nimport xpath from \"xpath\";\nimport { State } from \"./lib/State\";\nimport { StatesMapper } from \"./StatesMapper\";\n\nclass KostalPikoMpPlus extends utils.Adapter {\n    refreshInterval: any = undefined;\n    hostIpRegex = /^http[s]?:\\/\\/[A-Za-z0-9\\.]+(:[0-9]{1,})?$/;\n\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({\n            ...options,\n            name: \"kostal-piko-mp-plus\",\n        });\n        this.on(\"ready\", this.onReady.bind(this));\n        this.on(\"unload\", this.onUnload.bind(this));\n    }\n\n    /**\n     * Is called when databases are connected and adapter received configuration.\n     */\n    private async onReady(): Promise<void> {\n        // Initialize your adapter here\n        // Reset the connection indicator during startup\n        this.setState(\"info.connection\", false, true);\n\n        // The adapters config (in the instance object everything under the attribute \"native\") is accessible via this.config:\n        this.log.debug(`config.serverIp: ${this.config.serverIp}`);\n        this.log.debug(`config.interval: ${this.config.interval}`);\n\n        if (!this.hostIpRegex.test(this.config.serverIp)) {\n            this.log.error(`config.serverIp: ${this.config.serverIp} is invalid - example http://192.168.0.100`);\n            return;\n        }\n\n        // Load states config\n        const states = StatesMapper.states;\n\n        const client = axios.create({\n            baseURL: `${this.config.serverIp}`,\n            timeout: 5000,\n            responseType: \"text\",\n            responseEncoding: \"utf8\",\n            httpsAgent: new https.Agent({\n                rejectUnauthorized: false,\n            }),\n        });\n\n        this.log.info(`axios client with base url ${this.config.serverIp} created`);\n        this.log.info(`init fetch states`);\n\n        try {\n            await this.refreshMeasurements(client, states);\n\n            this.log.info(`starting auto refresh each ${this.config.interval} millis`);\n            this.refreshInterval = this.setInterval(async () => {\n                this.log.info(`refreshing states`);\n                await this.refreshMeasurements(client, states);\n            }, this.config.interval);\n        } catch (error) {\n            this.log.error(`set connection state to false and stop interval`);\n            this.setState(\"info.connection\", false, true);\n            this.clearInterval(this.refreshInterval);\n            if (axios.isAxiosError(error)) {\n                this.log.error(`error message: ${error.message} - ${error.response?.data}`);\n            } else {\n                this.log.error(`unexpected error: ${error}`);\n            }\n        }\n    }\n\n    private async refreshMeasurements(client: AxiosInstance, states: State[]): Promise<void> {\n        const { data, status } = await client.get(\"/measurements.xml\");\n        this.log.debug(`request to /measurements.xml with status ${status}`);\n        if (status == 200) {\n            this.setState(\"info.connection\", true, true);\n            const dom = new DOMParser().parseFromString(data);\n            await this.updateStates(dom, states);\n        } else {\n            this.log.error(`unexpected status code: ${status}`);\n        }\n    }\n\n    private async updateStates(dom: Document, states: State[]): Promise<void> {\n        for (const s of states) {\n            let selectedValue = xpath.select1(s.xpathValue, dom);\n\n            let value: any;\n\n            if (selectedValue !== undefined) {\n                value = (<Attr>selectedValue).value;\n            }\n\n            let unit = null;\n            if (s.xpathUnit !== undefined) {\n                selectedValue = xpath.select1(s.xpathUnit, dom);\n                unit = (<Attr>selectedValue).value;\n            }\n\n            if (value !== undefined) {\n                this.log.debug(`found state ${s.id} - ${value}`);\n                const common: ioBroker.StateCommon = {\n                    name: s.name,\n                    type: s.type ? s.type : \"string\",\n                    read: s.read ? s.read : true,\n                    write: s.write ? s.write : false,\n                    role: s.role ? s.role : \"state\",\n                    unit: unit !== null ? unit : undefined,\n                };\n\n                await this.setObjectNotExistsAsync(s.id, {\n                    type: \"state\",\n                    common: common,\n                    native: {},\n                });\n\n                value = this.convertStringTo(value, common.type);\n\n                await this.setStateAsync(s.id, { val: value, ack: true });\n            } else {\n                this.log.debug(`${s.id} has no value so we ignore it and we can delete it`);\n                await this.delObjectAsync(s.id);\n            }\n        }\n    }\n\n    /**\n     * Is called when adapter shuts down - callback has to be called under any circumstances!\n     */\n    private onUnload(callback: () => void): void {\n        try {\n            this.setState(\"info.connection\", false, true);\n            this.clearInterval(this.refreshInterval);\n            callback();\n        } catch (e) {\n            callback();\n        }\n    }\n\n    private convertStringTo(value: string, typeString: string | undefined): any {\n        this.log.debug(`try to convert ${value} to ${typeString}`);\n\n        let convertedValue: any;\n        if (typeString == \"number\") {\n            convertedValue = Number(value);\n        } else if (typeString == \"string\") {\n            convertedValue = value;\n        } else {\n            throw new Error(`unknown cast type - ${typeString}`);\n        }\n        return convertedValue;\n    }\n}\n\nif (require.main !== module) {\n    // Export the constructor in compact mode\n    module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new KostalPikoMpPlus(options);\n} else {\n    // otherwise start the instance directly\n    (() => new KostalPikoMpPlus())();\n}\n"],
  "mappings": "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",
  "names": []
}
