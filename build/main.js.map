{
  "version": 3,
  "sources": ["../src/main.ts"],
  "sourcesContent": ["/*\n * Created with @iobroker/create-adapter v2.1.1\n */\n\n// The adapter-core module gives you access to the core ioBroker functions\n// you need to create an adapter\nimport * as utils from \"@iobroker/adapter-core\";\n// Load your modules here, e.g.:\nimport axios from \"axios\";\nimport { DOMParser } from \"xmldom\";\nimport xpath from \"xpath\";\nimport { State } from \"./lib/State\";\nimport { StatesMapper } from \"./StatesMapper\";\n\nclass KostalPikoMpPlus extends utils.Adapter {\n    refreshInterval: any = undefined;\n\n    public constructor(options: Partial<utils.AdapterOptions> = {}) {\n        super({\n            ...options,\n            name: \"kostal-piko-mp-plus\",\n        });\n        this.on(\"ready\", this.onReady.bind(this));\n        // this.on(\"stateChange\", this.onStateChange.bind(this));\n        // this.on(\"objectChange\", this.onObjectChange.bind(this));\n        // this.on(\"message\", this.onMessage.bind(this));\n        this.on(\"unload\", this.onUnload.bind(this));\n    }\n\n    /**\n     * Is called when databases are connected and adapter received configuration.\n     */\n    private async onReady(): Promise<void> {\n        // Initialize your adapter here\n        const states = StatesMapper.states;\n        // Reset the connection indicator during startup\n        this.setState(\"info.connection\", false, true);\n\n        // The adapters config (in the instance object everything under the attribute \"native\") is accessible via this.config:\n        this.log.debug(\"config.serverIp: \" + this.config.serverIp);\n        this.log.debug(\"config.interval: \" + this.config.interval);\n\n        const requestURL = `${this.config.serverIp}/measurements.xml`;\n        const requestHeader = { headers: { Accept: \"application/xml\" } };\n\n        this.refreshInterval = this.setInterval(async () => {\n            try {\n                const { data, status } = await axios.get<string>(requestURL, requestHeader);\n\n                this.setState(\"info.connection\", true, true);\n\n                this.log.debug(`request to ${requestURL} with status ${status}`);\n                const dom = new DOMParser().parseFromString(data);\n                await this.updateStates(dom, states);\n            } catch (error) {\n                this.setState(\"info.connection\", false, true);\n                this.clearInterval(this.refreshInterval);\n                if (axios.isAxiosError(error)) {\n                    this.log.error(`error message: ${error.message}`);\n                } else {\n                    this.log.error(`unexpected error: ${error}`);\n                }\n            }\n        }, this.config.interval);\n\n        /*\n\t\tFor every state in the system there has to be also an object of type state\n\t\tHere a simple template for a boolean variable named \"testVariable\"\n\t\tBecause every adapter instance uses its own unique namespace variable names can't collide with other adapters variables\n\t\t*/\n        /*\n        await this.setObjectNotExistsAsync(\"testVariable\", {\n            type: \"state\",\n            common: {\n                name: \"testVariable\",\n                type: \"boolean\",\n                role: \"indicator\",\n                read: true,\n                write: true,\n            },\n            native: {},\n        });\n        */\n        // In order to get state updates, you need to subscribe to them. The following line adds a subscription for our variable we have created above.\n        //this.subscribeStates(\"testVariable\");\n        // You can also add a subscription for multiple states. The following line watches all states starting with \"lights.\"\n        // this.subscribeStates(\"lights.*\");\n        // Or, if you really must, you can also watch all states. Don't do this if you don't need to. Otherwise this will cause a lot of unnecessary load on the system:\n        // this.subscribeStates(\"*\");\n\n        /*\n\t\t\tsetState examples\n\t\t\tyou will notice that each setState will cause the stateChange event to fire (because of above subscribeStates cmd)\n\t\t*/\n        // the variable testVariable is set to true as command (ack=false)\n        //await this.setStateAsync(\"testVariable\", true);\n\n        // same thing, but the value is flagged \"ack\"\n        // ack should be always set to true if the value is received from or acknowledged from the target system\n        //await this.setStateAsync(\"testVariable\", { val: true, ack: true });\n\n        // same thing, but the state is deleted after 30s (getState will return null afterwards)\n        //await this.setStateAsync(\"testVariable\", { val: true, ack: true, expire: 30 });\n\n        // examples for the checkPassword/checkGroup functions\n        //let result = await this.checkPasswordAsync(\"admin\", \"iobroker\");\n        //this.log.info(\"check user admin pw iobroker: \" + result);\n\n        //result = await this.checkGroupAsync(\"admin\", \"admin\");\n        //this.log.info(\"check group user admin group admin: \" + result);\n    }\n\n    private async updateStates(dom: Document, states: State[]): Promise<void> {\n        for (const s of states) {\n            let selectedValue = xpath.select1(s.xpathValue, dom);\n\n            let value: any;\n\n            if (selectedValue !== undefined) {\n                value = (<Attr>selectedValue).value;\n            }\n\n            let unit = null;\n            if (s.xpathUnit !== undefined) {\n                selectedValue = xpath.select1(s.xpathUnit, dom);\n                unit = (<Attr>selectedValue).value;\n            }\n\n            if (value !== undefined) {\n                if (s.type == \"number\") {\n                    value = Number(value);\n                } else if (s.type == \"string\") {\n                    this.log.debug(`${s.id}:${value} - it is a string then it remains a string`);\n                } else {\n                    this.log.error(`unknown cast type`);\n                }\n            }\n\n            if (value !== undefined) {\n                this.log.debug(`${s.id} has a value so we add this object with ${value} its ${typeof value}`);\n                const common: ioBroker.StateCommon = {\n                    name: s.name,\n                    type: s.type,\n                    read: s.read,\n                    write: s.write,\n                    role: \"state\",\n                    unit: unit !== null ? unit : undefined,\n                };\n\n                await this.setObjectNotExistsAsync(s.id, {\n                    type: \"state\",\n                    common: common,\n                    native: {},\n                });\n                await this.setStateAsync(s.id, { val: value, ack: true });\n            } else {\n                this.log.debug(`${s.id} has no value so we ignore it and we can delete it`);\n                await this.delObjectAsync(s.id);\n            }\n        }\n    }\n\n    /**\n     * Is called when adapter shuts down - callback has to be called under any circumstances!\n     */\n    private onUnload(callback: () => void): void {\n        try {\n            this.clearInterval(this.refreshInterval);\n            // Here you must clear all timeouts or intervals that may still be active\n            // clearTimeout(timeout1);\n            callback();\n        } catch (e) {\n            callback();\n        }\n    }\n\n    // If you need to react to object changes, uncomment the following block and the corresponding line in the constructor.\n    // You also need to subscribe to the objects with `this.subscribeObjects`, similar to `this.subscribeStates`.\n    // /**\n    //  * Is called if a subscribed object changes\n    //  */\n    // private onObjectChange(id: string, obj: ioBroker.Object | null | undefined): void {\n    //     if (obj) {\n    //         // The object was changed\n    //         this.log.info(`object ${id} changed: ${JSON.stringify(obj)}`);\n    //     } else {\n    //         // The object was deleted\n    //         this.log.info(`object ${id} deleted`);\n    //     }\n    // }\n\n    /**\n     * Is called if a subscribed state changes\n     */\n    /*\n    private onStateChange(id: string, state: ioBroker.State | null | undefined): void {\n        if (state) {\n            // The state was changed\n            this.log.info(`state ${id} changed: ${state.val} (ack = ${state.ack})`);\n        } else {\n            // The state was deleted\n            this.log.info(`state ${id} deleted`);\n        }\n    }\n    */\n    // If you need to accept messages in your adapter, uncomment the following block and the corresponding line in the constructor.\n    // /**\n    //  * Some message was sent to this instance over message box. Used by email, pushover, text2speech, ...\n    //  * Using this method requires \"common.messagebox\" property to be set to true in io-package.json\n    //  */\n    // private onMessage(obj: ioBroker.Message): void {\n    //     if (typeof obj === \"object\" && obj.message) {\n    //         if (obj.command === \"send\") {\n    //             // e.g. send email or pushover or whatever\n    //             this.log.info(\"send command\");\n\n    //             // Send response in callback if required\n    //             if (obj.callback) this.sendTo(obj.from, obj.command, \"Message received\", obj.callback);\n    //         }\n    //     }\n    // }\n}\n\nif (require.main !== module) {\n    // Export the constructor in compact mode\n    module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new KostalPikoMpPlus(options);\n} else {\n    // otherwise start the instance directly\n    (() => new KostalPikoMpPlus())();\n}\n"],
  "mappings": "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",
  "names": []
}
